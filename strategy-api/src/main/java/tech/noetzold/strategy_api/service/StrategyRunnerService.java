package tech.noetzold.strategy_api.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.FluxSink;
import tech.noetzold.strategy_api.context.BinanceEnvironmentContext;
import tech.noetzold.strategy_api.enums.BinanceEnvironment;
import tech.noetzold.strategy_api.model.CustomStrategy;
import tech.noetzold.strategy_api.model.StrategyExecutionLog;
import tech.noetzold.strategy_api.model.User;
import tech.noetzold.strategy_api.repository.CustomStrategyRepository;
import tech.noetzold.strategy_api.repository.StrategyExecutionLogRepository;
import tech.noetzold.strategy_api.strategy.BaseStrategy;

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

@Slf4j
@Service
public class StrategyRunnerService {

    private final Map<String, BaseStrategy> strategyBeans;
    private final ExecutorService executor = Executors.newCachedThreadPool();
    private final Map<String, Future<?>> runningStrategies = new ConcurrentHashMap<>();
    private final Map<String, FluxSink<String>> logSubscribers = new ConcurrentHashMap<>();
    private final StrategyExecutionLogRepository strategyExecutionLogRepository;
    private final CustomStrategyRepository customStrategyRepository;

    public StrategyRunnerService(List<BaseStrategy> strategyBeanList,
                                 StrategyExecutionLogRepository strategyExecutionLogRepository,
                                 CustomStrategyRepository customStrategyRepository) {
        this.strategyExecutionLogRepository = strategyExecutionLogRepository;
        this.customStrategyRepository = customStrategyRepository;

        // üõ†Ô∏è Substituindo tentativa de usar valor de anota√ß√£o @Service por nome da classe em lowercase
        this.strategyBeans = strategyBeanList.stream()
                .collect(Collectors.toMap(
                        bean -> bean.getClass().getSimpleName().toLowerCase(),  // nome da classe como chave
                        bean -> bean
                ));
    }

    public List<String> listAvailableStrategies() {
        List<String> custom = customStrategyRepository.findAll()
                .stream().map(CustomStrategy::getName).toList();
        List<String> fixed = new ArrayList<>(strategyBeans.keySet());
        fixed.addAll(custom);
        return fixed;
    }

    public String runStrategy(String strategyName, Map<String, String> params, User user) {
        if (strategyBeans.containsKey(strategyName)) {
            BaseStrategy strategy = strategyBeans.get(strategyName);
            try {
                String apiKey = getApiKey(user);
                String secretKey = getSecretKey(user);
                log.info("üöÄ Executando estrat√©gia fixa: {} com usu√°rio {}", strategyName, user.getEmail());
                return strategy.run(params, apiKey, secretKey);
            } catch (Exception e) {
                log.error("‚ùå Erro ao executar estrat√©gia fixa", e);
                return "Erro: " + e.getMessage();
            }
        } else {
            Optional<CustomStrategy> customOpt = customStrategyRepository.findByName(strategyName);
            if (customOpt.isPresent()) {
                try {
                    String apiKey = getApiKey(user);
                    String secretKey = getSecretKey(user);
                    CustomStrategy custom = customOpt.get();
                    log.info("üöÄ Executando estrat√©gia customizada: {} para {}", strategyName, user.getEmail());
                    return custom.execute(params, apiKey, secretKey);
                } catch (Exception e) {
                    log.error("‚ùå Erro ao executar estrat√©gia customizada", e);
                    return "Erro na custom strategy: " + e.getMessage();
                }
            } else {
                return "‚ùå Estrat√©gia n√£o encontrada: " + strategyName;
            }
        }
    }

    public String runStrategyAsync(String strategyName, Map<String, String> params, User user) {
        if (runningStrategies.containsKey(strategyName)) {
            return "‚ö†Ô∏è Estrat√©gia j√° est√° em execu√ß√£o: " + strategyName;
        }

        long interval = getIntervalInMillis(params.getOrDefault("interval", "60"));

        Runnable task = () -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    publishLog(strategyName, "‚è≥ Executando estrat√©gia '" + strategyName + "'...", user);
                    String result = runStrategy(strategyName, params, user);
                    publishLog(strategyName, "‚úÖ Resultado: " + result, user);
                    Thread.sleep(interval);
                }
            } catch (InterruptedException e) {
                publishLog(strategyName, "üõë Estrat√©gia '" + strategyName + "' interrompida.", user);
                Thread.currentThread().interrupt();
            } catch (Exception e) {
                log.error("‚ùå Erro na execu√ß√£o da estrat√©gia: {}", strategyName, e);
                publishLog(strategyName, "‚ùå Erro: " + e.getMessage(), user);
            }
        };

        Future<?> future = executor.submit(task);
        runningStrategies.put(strategyName, future);
        return "üü¢ Execu√ß√£o da estrat√©gia iniciada: " + strategyName;
    }

    public String stopStrategy(String strategyName) {
        Future<?> future = runningStrategies.remove(strategyName);
        if (future != null) {
            future.cancel(true);
            publishLog(strategyName, "üõë Estrat√©gia parada: " + strategyName, null);
            return "üõë Estrat√©gia parada: " + strategyName;
        } else {
            return "‚ö†Ô∏è Estrat√©gia n√£o estava em execu√ß√£o: " + strategyName;
        }
    }

    public boolean isStrategyRegistered(String strategyName) {
        return strategyBeans.containsKey(strategyName)
                || customStrategyRepository.findByName(strategyName).isPresent();
    }

    public void registerLogSubscriber(String strategyName, FluxSink<String> sink) {
        logSubscribers.put(strategyName, sink);
        publishLog(strategyName, "üì° Conectado para receber logs da estrat√©gia '" + strategyName + "'", null);
    }

    public void unregisterLogSubscriber(String strategyName) {
        logSubscribers.remove(strategyName);
    }

    private void publishLog(String strategyName, String logMessage, User user) {
        log.info("[{}] {}", strategyName, logMessage);
        FluxSink<String> sink = logSubscribers.get(strategyName);
        if (sink != null) {
            sink.next(logMessage);
        }

        if (user != null) {
            try {
                StrategyExecutionLog logEntry = new StrategyExecutionLog();
                logEntry.setStrategyName(strategyName);
                logEntry.setMessage(logMessage);
                logEntry.setUser(user);
                strategyExecutionLogRepository.save(logEntry);
            } catch (Exception e) {
                log.warn("‚ö†Ô∏è N√£o foi poss√≠vel salvar log no banco: {}", e.getMessage());
            }
        }
    }

    private long getIntervalInMillis(String intervalParam) {
        try {
            if (intervalParam.endsWith("s")) {
                return Long.parseLong(intervalParam.replace("s", "")) * 1000L;
            } else if (intervalParam.endsWith("m")) {
                return Long.parseLong(intervalParam.replace("m", "")) * 60_000L;
            } else if (intervalParam.endsWith("h")) {
                return Long.parseLong(intervalParam.replace("h", "")) * 60 * 60_000L;
            } else {
                return Long.parseLong(intervalParam) * 1000L;
            }
        } catch (NumberFormatException e) {
            return 60_000L;
        }
    }

    private String getApiKey(User user) {
        return BinanceEnvironmentContext.get() == BinanceEnvironment.PRODUCTION
                ? user.getProductionApiKey()
                : user.getTestnetApiKey();
    }

    private String getSecretKey(User user) {
        return BinanceEnvironmentContext.get() == BinanceEnvironment.PRODUCTION
                ? user.getProductionSecretKey()
                : user.getTestnetSecretKey();
    }
}
